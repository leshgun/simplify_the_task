// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'task_list_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$TaskListEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TaskListEventCopyWith<$Res> {
  factory $TaskListEventCopyWith(
          TaskListEvent value, $Res Function(TaskListEvent) then) =
      _$TaskListEventCopyWithImpl<$Res, TaskListEvent>;
}

/// @nodoc
class _$TaskListEventCopyWithImpl<$Res, $Val extends TaskListEvent>
    implements $TaskListEventCopyWith<$Res> {
  _$TaskListEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TaskListLoadCopyWith<$Res> {
  factory _$$TaskListLoadCopyWith(
          _$TaskListLoad value, $Res Function(_$TaskListLoad) then) =
      __$$TaskListLoadCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TaskListLoadCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListLoad>
    implements _$$TaskListLoadCopyWith<$Res> {
  __$$TaskListLoadCopyWithImpl(
      _$TaskListLoad _value, $Res Function(_$TaskListLoad) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TaskListLoad implements TaskListLoad {
  const _$TaskListLoad();

  @override
  String toString() {
    return 'TaskListEvent.load()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TaskListLoad);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return load();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return load?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (load != null) {
      return load();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return load(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return load?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (load != null) {
      return load(this);
    }
    return orElse();
  }
}

abstract class TaskListLoad implements TaskListEvent {
  const factory TaskListLoad() = _$TaskListLoad;
}

/// @nodoc
abstract class _$$TaskListSaveCopyWith<$Res> {
  factory _$$TaskListSaveCopyWith(
          _$TaskListSave value, $Res Function(_$TaskListSave) then) =
      __$$TaskListSaveCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TaskListSaveCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListSave>
    implements _$$TaskListSaveCopyWith<$Res> {
  __$$TaskListSaveCopyWithImpl(
      _$TaskListSave _value, $Res Function(_$TaskListSave) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TaskListSave implements TaskListSave {
  const _$TaskListSave();

  @override
  String toString() {
    return 'TaskListEvent.save()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TaskListSave);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return save();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return save?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (save != null) {
      return save();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return save(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return save?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (save != null) {
      return save(this);
    }
    return orElse();
  }
}

abstract class TaskListSave implements TaskListEvent {
  const factory TaskListSave() = _$TaskListSave;
}

/// @nodoc
<<<<<<< HEAD
abstract class _$$TaskListSynchCopyWith<$Res> {
  factory _$$TaskListSynchCopyWith(
          _$TaskListSynch value, $Res Function(_$TaskListSynch) then) =
      __$$TaskListSynchCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TaskListSynchCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListSynch>
    implements _$$TaskListSynchCopyWith<$Res> {
  __$$TaskListSynchCopyWithImpl(
      _$TaskListSynch _value, $Res Function(_$TaskListSynch) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TaskListSynch implements TaskListSynch {
  const _$TaskListSynch();

  @override
  String toString() {
    return 'TaskListEvent.synch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TaskListSynch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
    required TResult Function() synch,
    required TResult Function() close,
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return synch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
    TResult? Function()? synch,
    TResult? Function()? close,
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return synch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
    TResult Function()? synch,
    TResult Function()? close,
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (synch != null) {
      return synch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return synch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return synch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (synch != null) {
      return synch(this);
    }
    return orElse();
  }
}

abstract class TaskListSynch implements TaskListEvent {
  const factory TaskListSynch() = _$TaskListSynch;
}

/// @nodoc
abstract class _$$TaskListCloseCopyWith<$Res> {
  factory _$$TaskListCloseCopyWith(
          _$TaskListClose value, $Res Function(_$TaskListClose) then) =
      __$$TaskListCloseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TaskListCloseCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListClose>
    implements _$$TaskListCloseCopyWith<$Res> {
  __$$TaskListCloseCopyWithImpl(
      _$TaskListClose _value, $Res Function(_$TaskListClose) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TaskListClose implements TaskListClose {
  const _$TaskListClose();

  @override
  String toString() {
    return 'TaskListEvent.close()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TaskListClose);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
    required TResult Function() synch,
    required TResult Function() close,
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return close();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
    TResult? Function()? synch,
    TResult? Function()? close,
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return close?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
    TResult Function()? synch,
    TResult Function()? close,
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (close != null) {
      return close();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return close(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return close?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (close != null) {
      return close(this);
    }
    return orElse();
  }
}

abstract class TaskListClose implements TaskListEvent {
  const factory TaskListClose() = _$TaskListClose;
}

/// @nodoc
=======
>>>>>>> d5b4746 (equitable => freezed)
abstract class _$$TaskListAddCopyWith<$Res> {
  factory _$$TaskListAddCopyWith(
          _$TaskListAdd value, $Res Function(_$TaskListAdd) then) =
      __$$TaskListAddCopyWithImpl<$Res>;
  @useResult
  $Res call({TaskModel task});

  $TaskModelCopyWith<$Res> get task;
}

/// @nodoc
class __$$TaskListAddCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListAdd>
    implements _$$TaskListAddCopyWith<$Res> {
  __$$TaskListAddCopyWithImpl(
      _$TaskListAdd _value, $Res Function(_$TaskListAdd) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? task = null,
  }) {
    return _then(_$TaskListAdd(
      task: null == task
          ? _value.task
          : task // ignore: cast_nullable_to_non_nullable
              as TaskModel,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TaskModelCopyWith<$Res> get task {
    return $TaskModelCopyWith<$Res>(_value.task, (value) {
      return _then(_value.copyWith(task: value));
    });
  }
}

/// @nodoc

class _$TaskListAdd implements TaskListAdd {
  const _$TaskListAdd({required this.task});

  @override
  final TaskModel task;

  @override
  String toString() {
    return 'TaskListEvent.add(task: $task)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TaskListAdd &&
            (identical(other.task, task) || other.task == task));
  }

  @override
  int get hashCode => Object.hash(runtimeType, task);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TaskListAddCopyWith<_$TaskListAdd> get copyWith =>
      __$$TaskListAddCopyWithImpl<_$TaskListAdd>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return add(task);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return add?.call(task);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(task);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class TaskListAdd implements TaskListEvent {
  const factory TaskListAdd({required final TaskModel task}) = _$TaskListAdd;

  TaskModel get task;
  @JsonKey(ignore: true)
  _$$TaskListAddCopyWith<_$TaskListAdd> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TaskListUpdateCopyWith<$Res> {
  factory _$$TaskListUpdateCopyWith(
          _$TaskListUpdate value, $Res Function(_$TaskListUpdate) then) =
      __$$TaskListUpdateCopyWithImpl<$Res>;
  @useResult
  $Res call({TaskModel task});

  $TaskModelCopyWith<$Res> get task;
}

/// @nodoc
class __$$TaskListUpdateCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListUpdate>
    implements _$$TaskListUpdateCopyWith<$Res> {
  __$$TaskListUpdateCopyWithImpl(
      _$TaskListUpdate _value, $Res Function(_$TaskListUpdate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? task = null,
  }) {
    return _then(_$TaskListUpdate(
      task: null == task
          ? _value.task
          : task // ignore: cast_nullable_to_non_nullable
              as TaskModel,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TaskModelCopyWith<$Res> get task {
    return $TaskModelCopyWith<$Res>(_value.task, (value) {
      return _then(_value.copyWith(task: value));
    });
  }
}

/// @nodoc

class _$TaskListUpdate implements TaskListUpdate {
  const _$TaskListUpdate({required this.task});

  @override
  final TaskModel task;

  @override
  String toString() {
    return 'TaskListEvent.update(task: $task)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TaskListUpdate &&
            (identical(other.task, task) || other.task == task));
  }

  @override
  int get hashCode => Object.hash(runtimeType, task);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TaskListUpdateCopyWith<_$TaskListUpdate> get copyWith =>
      __$$TaskListUpdateCopyWithImpl<_$TaskListUpdate>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return update(task);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return update?.call(task);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(task);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class TaskListUpdate implements TaskListEvent {
  const factory TaskListUpdate({required final TaskModel task}) =
      _$TaskListUpdate;

  TaskModel get task;
  @JsonKey(ignore: true)
  _$$TaskListUpdateCopyWith<_$TaskListUpdate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TaskListDeleteCopyWith<$Res> {
  factory _$$TaskListDeleteCopyWith(
          _$TaskListDelete value, $Res Function(_$TaskListDelete) then) =
      __$$TaskListDeleteCopyWithImpl<$Res>;
  @useResult
  $Res call({TaskModel task});

  $TaskModelCopyWith<$Res> get task;
}

/// @nodoc
class __$$TaskListDeleteCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListDelete>
    implements _$$TaskListDeleteCopyWith<$Res> {
  __$$TaskListDeleteCopyWithImpl(
      _$TaskListDelete _value, $Res Function(_$TaskListDelete) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? task = null,
  }) {
    return _then(_$TaskListDelete(
      task: null == task
          ? _value.task
          : task // ignore: cast_nullable_to_non_nullable
              as TaskModel,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TaskModelCopyWith<$Res> get task {
    return $TaskModelCopyWith<$Res>(_value.task, (value) {
      return _then(_value.copyWith(task: value));
    });
  }
}

/// @nodoc

class _$TaskListDelete implements TaskListDelete {
  const _$TaskListDelete({required this.task});

  @override
  final TaskModel task;

  @override
  String toString() {
    return 'TaskListEvent.delete(task: $task)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TaskListDelete &&
            (identical(other.task, task) || other.task == task));
  }

  @override
  int get hashCode => Object.hash(runtimeType, task);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TaskListDeleteCopyWith<_$TaskListDelete> get copyWith =>
      __$$TaskListDeleteCopyWithImpl<_$TaskListDelete>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return delete(task);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return delete?.call(task);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(task);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return delete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return delete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(this);
    }
    return orElse();
  }
}

abstract class TaskListDelete implements TaskListEvent {
  const factory TaskListDelete({required final TaskModel task}) =
      _$TaskListDelete;

  TaskModel get task;
  @JsonKey(ignore: true)
  _$$TaskListDeleteCopyWith<_$TaskListDelete> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TaskListToggleCopyWith<$Res> {
  factory _$$TaskListToggleCopyWith(
          _$TaskListToggle value, $Res Function(_$TaskListToggle) then) =
      __$$TaskListToggleCopyWithImpl<$Res>;
  @useResult
  $Res call({TaskModel task});

  $TaskModelCopyWith<$Res> get task;
}

/// @nodoc
class __$$TaskListToggleCopyWithImpl<$Res>
    extends _$TaskListEventCopyWithImpl<$Res, _$TaskListToggle>
    implements _$$TaskListToggleCopyWith<$Res> {
  __$$TaskListToggleCopyWithImpl(
      _$TaskListToggle _value, $Res Function(_$TaskListToggle) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? task = null,
  }) {
    return _then(_$TaskListToggle(
      task: null == task
          ? _value.task
          : task // ignore: cast_nullable_to_non_nullable
              as TaskModel,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TaskModelCopyWith<$Res> get task {
    return $TaskModelCopyWith<$Res>(_value.task, (value) {
      return _then(_value.copyWith(task: value));
    });
  }
}

/// @nodoc

class _$TaskListToggle implements TaskListToggle {
  const _$TaskListToggle({required this.task});

  @override
  final TaskModel task;

  @override
  String toString() {
    return 'TaskListEvent.toggle(task: $task)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TaskListToggle &&
            (identical(other.task, task) || other.task == task));
  }

  @override
  int get hashCode => Object.hash(runtimeType, task);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TaskListToggleCopyWith<_$TaskListToggle> get copyWith =>
      __$$TaskListToggleCopyWithImpl<_$TaskListToggle>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() load,
    required TResult Function() save,
<<<<<<< HEAD
    required TResult Function() synch,
    required TResult Function() close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskModel task) add,
    required TResult Function(TaskModel task) update,
    required TResult Function(TaskModel task) delete,
    required TResult Function(TaskModel task) toggle,
  }) {
    return toggle(task);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? load,
    TResult? Function()? save,
<<<<<<< HEAD
    TResult? Function()? synch,
    TResult? Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskModel task)? add,
    TResult? Function(TaskModel task)? update,
    TResult? Function(TaskModel task)? delete,
    TResult? Function(TaskModel task)? toggle,
  }) {
    return toggle?.call(task);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? load,
    TResult Function()? save,
<<<<<<< HEAD
    TResult Function()? synch,
    TResult Function()? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskModel task)? add,
    TResult Function(TaskModel task)? update,
    TResult Function(TaskModel task)? delete,
    TResult Function(TaskModel task)? toggle,
    required TResult orElse(),
  }) {
    if (toggle != null) {
      return toggle(task);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TaskListLoad value) load,
    required TResult Function(TaskListSave value) save,
<<<<<<< HEAD
    required TResult Function(TaskListSynch value) synch,
    required TResult Function(TaskListClose value) close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    required TResult Function(TaskListAdd value) add,
    required TResult Function(TaskListUpdate value) update,
    required TResult Function(TaskListDelete value) delete,
    required TResult Function(TaskListToggle value) toggle,
  }) {
    return toggle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TaskListLoad value)? load,
    TResult? Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult? Function(TaskListSynch value)? synch,
    TResult? Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult? Function(TaskListAdd value)? add,
    TResult? Function(TaskListUpdate value)? update,
    TResult? Function(TaskListDelete value)? delete,
    TResult? Function(TaskListToggle value)? toggle,
  }) {
    return toggle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TaskListLoad value)? load,
    TResult Function(TaskListSave value)? save,
<<<<<<< HEAD
    TResult Function(TaskListSynch value)? synch,
    TResult Function(TaskListClose value)? close,
=======
>>>>>>> d5b4746 (equitable => freezed)
    TResult Function(TaskListAdd value)? add,
    TResult Function(TaskListUpdate value)? update,
    TResult Function(TaskListDelete value)? delete,
    TResult Function(TaskListToggle value)? toggle,
    required TResult orElse(),
  }) {
    if (toggle != null) {
      return toggle(this);
    }
    return orElse();
  }
}

abstract class TaskListToggle implements TaskListEvent {
  const factory TaskListToggle({required final TaskModel task}) =
      _$TaskListToggle;

  TaskModel get task;
  @JsonKey(ignore: true)
  _$$TaskListToggleCopyWith<_$TaskListToggle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TaskListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<TaskModel> taskList) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<TaskModel> taskList)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<TaskModel> taskList)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TaskListInitial value) initial,
    required TResult Function(_TaskListLoading value) loading,
    required TResult Function(_TaskListLoaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TaskListInitial value)? initial,
    TResult? Function(_TaskListLoading value)? loading,
    TResult? Function(_TaskListLoaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TaskListInitial value)? initial,
    TResult Function(_TaskListLoading value)? loading,
    TResult Function(_TaskListLoaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TaskListStateCopyWith<$Res> {
  factory $TaskListStateCopyWith(
          TaskListState value, $Res Function(TaskListState) then) =
      _$TaskListStateCopyWithImpl<$Res, TaskListState>;
}

/// @nodoc
class _$TaskListStateCopyWithImpl<$Res, $Val extends TaskListState>
    implements $TaskListStateCopyWith<$Res> {
  _$TaskListStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_TaskListInitialCopyWith<$Res> {
  factory _$$_TaskListInitialCopyWith(
          _$_TaskListInitial value, $Res Function(_$_TaskListInitial) then) =
      __$$_TaskListInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TaskListInitialCopyWithImpl<$Res>
    extends _$TaskListStateCopyWithImpl<$Res, _$_TaskListInitial>
    implements _$$_TaskListInitialCopyWith<$Res> {
  __$$_TaskListInitialCopyWithImpl(
      _$_TaskListInitial _value, $Res Function(_$_TaskListInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_TaskListInitial implements _TaskListInitial {
  const _$_TaskListInitial();

  @override
  String toString() {
    return 'TaskListState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_TaskListInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<TaskModel> taskList) loaded,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<TaskModel> taskList)? loaded,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<TaskModel> taskList)? loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TaskListInitial value) initial,
    required TResult Function(_TaskListLoading value) loading,
    required TResult Function(_TaskListLoaded value) loaded,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TaskListInitial value)? initial,
    TResult? Function(_TaskListLoading value)? loading,
    TResult? Function(_TaskListLoaded value)? loaded,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TaskListInitial value)? initial,
    TResult Function(_TaskListLoading value)? loading,
    TResult Function(_TaskListLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _TaskListInitial implements TaskListState {
  const factory _TaskListInitial() = _$_TaskListInitial;
}

/// @nodoc
abstract class _$$_TaskListLoadingCopyWith<$Res> {
  factory _$$_TaskListLoadingCopyWith(
          _$_TaskListLoading value, $Res Function(_$_TaskListLoading) then) =
      __$$_TaskListLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TaskListLoadingCopyWithImpl<$Res>
    extends _$TaskListStateCopyWithImpl<$Res, _$_TaskListLoading>
    implements _$$_TaskListLoadingCopyWith<$Res> {
  __$$_TaskListLoadingCopyWithImpl(
      _$_TaskListLoading _value, $Res Function(_$_TaskListLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_TaskListLoading implements _TaskListLoading {
  const _$_TaskListLoading();

  @override
  String toString() {
    return 'TaskListState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_TaskListLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<TaskModel> taskList) loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<TaskModel> taskList)? loaded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<TaskModel> taskList)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TaskListInitial value) initial,
    required TResult Function(_TaskListLoading value) loading,
    required TResult Function(_TaskListLoaded value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TaskListInitial value)? initial,
    TResult? Function(_TaskListLoading value)? loading,
    TResult? Function(_TaskListLoaded value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TaskListInitial value)? initial,
    TResult Function(_TaskListLoading value)? loading,
    TResult Function(_TaskListLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _TaskListLoading implements TaskListState {
  const factory _TaskListLoading() = _$_TaskListLoading;
}

/// @nodoc
abstract class _$$_TaskListLoadedCopyWith<$Res> {
  factory _$$_TaskListLoadedCopyWith(
          _$_TaskListLoaded value, $Res Function(_$_TaskListLoaded) then) =
      __$$_TaskListLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<TaskModel> taskList});
}

/// @nodoc
class __$$_TaskListLoadedCopyWithImpl<$Res>
    extends _$TaskListStateCopyWithImpl<$Res, _$_TaskListLoaded>
    implements _$$_TaskListLoadedCopyWith<$Res> {
  __$$_TaskListLoadedCopyWithImpl(
      _$_TaskListLoaded _value, $Res Function(_$_TaskListLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? taskList = null,
  }) {
    return _then(_$_TaskListLoaded(
      taskList: null == taskList
          ? _value._taskList
          : taskList // ignore: cast_nullable_to_non_nullable
              as List<TaskModel>,
    ));
  }
}

/// @nodoc

class _$_TaskListLoaded implements _TaskListLoaded {
  const _$_TaskListLoaded({required final List<TaskModel> taskList})
      : _taskList = taskList;

  final List<TaskModel> _taskList;
  @override
  List<TaskModel> get taskList {
    if (_taskList is EqualUnmodifiableListView) return _taskList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_taskList);
  }

  @override
  String toString() {
    return 'TaskListState.loaded(taskList: $taskList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TaskListLoaded &&
            const DeepCollectionEquality().equals(other._taskList, _taskList));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_taskList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TaskListLoadedCopyWith<_$_TaskListLoaded> get copyWith =>
      __$$_TaskListLoadedCopyWithImpl<_$_TaskListLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<TaskModel> taskList) loaded,
  }) {
    return loaded(taskList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<TaskModel> taskList)? loaded,
  }) {
    return loaded?.call(taskList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<TaskModel> taskList)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(taskList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TaskListInitial value) initial,
    required TResult Function(_TaskListLoading value) loading,
    required TResult Function(_TaskListLoaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TaskListInitial value)? initial,
    TResult? Function(_TaskListLoading value)? loading,
    TResult? Function(_TaskListLoaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TaskListInitial value)? initial,
    TResult Function(_TaskListLoading value)? loading,
    TResult Function(_TaskListLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _TaskListLoaded implements TaskListState {
  const factory _TaskListLoaded({required final List<TaskModel> taskList}) =
      _$_TaskListLoaded;

  List<TaskModel> get taskList;
  @JsonKey(ignore: true)
  _$$_TaskListLoadedCopyWith<_$_TaskListLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}
